import java.util.Random;class Scheduler {    final static int NUMBER_RUN_TIMES = 5;    final static int CPU_BURST_TIME_MIN = 1;    final static int CPU_BURST_TIME_MAX = 100;    final static int ARRIVAL_TIME_MIN = 1;    final static int ARRIVAL_TIME_MAX = 1000;    final static int PRIORITY_MIN = 1;    final static int PRIORITY_MAX = 10;    Scheduler(int numberOfProcesses) {        // Todo: Loop run number with different seeds        // Todo: Iterate for N = 100 and N = 500        int tail = numberOfProcesses - 1;        Process[] processList;        processList = new Process[numberOfProcesses];        float waiting = 0;        float turnaround = 0;        //Instantiate all processes        for(int k = 0; k < NUMBER_RUN_TIMES; k++) {            Random rng = new Random(k); // initialize a random generator with different seed            // create N number of processes            for (int i = 0; i < numberOfProcesses; i++) {                int CPUBurst = rng.nextInt(CPU_BURST_TIME_MAX - CPU_BURST_TIME_MIN + 1) + CPU_BURST_TIME_MIN;                int arrivalTime = rng.nextInt(ARRIVAL_TIME_MAX - ARRIVAL_TIME_MIN + 1) + ARRIVAL_TIME_MIN;                int priority = rng.nextInt(PRIORITY_MAX - PRIORITY_MIN + 1) + PRIORITY_MIN;                processList[i] = new Process(i, CPUBurst, arrivalTime, priority);            }            // sort by arrival time            for (int i = 0; i < numberOfProcesses; i++) {                for (int j = 0; j < numberOfProcesses; j++) {                    if (processList[i].arrival < processList[j].arrival) {                        Process temp = new Process(processList[i]);                        processList[i] = processList[j];                        processList[j] = temp;                    }                }            }            //Initialize time to first arrived Process time            int head = 0;            int time = processList[head].arrival;            /* Sorting Algorithm            * After sorting by arrival time, head and tail are used to            * indicate the "sub-array" that the CPU is sorting by priority            * with respect to the time that has elapsed. */            while (head != numberOfProcesses -1) {                //Find tail                for (int i = 0; i < numberOfProcesses; i++) {                    if (processList[i].arrival <= time) {                        tail = i;                    } else {                        break;                    }                }                //Sort by Priority                for (int i = head; i <= tail; i++) {                    for (int j = head; j <= tail; j++) {                        if (processList[i].priority < processList[j].priority) {                            Process temp = new Process(processList[i]);                            processList[i] = processList[j];                            processList[j] = temp;                        }                    }                }                time = time + processList[head].burst; // Timer after burst                head = head + 1; //Increment head            }            time = processList[0].arrival;            //calculate wait time and turnaround time            for (int i = 0; i < numberOfProcesses; i++)            {                waiting = waiting + time - processList[i].arrival;                time = time + processList[i].burst;                turnaround = turnaround + time - processList[i].arrival;            }            turnaround = turnaround / numberOfProcesses;            waiting = waiting / numberOfProcesses;            //Table Output            System.out.print("|\t");            System.out.print(numberOfProcesses + "\t");            System.out.print("|");            System.out.print("\t" + (k+1) + "\t");            System.out.print("\t|");            System.out.print("\t" + waiting + " ns \t");            System.out.print("|");            System.out.print("\t" + turnaround + " ns\t");            System.out.println("|");        }    }}